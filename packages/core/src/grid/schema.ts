import { JsocGridError } from '../errors';
import { generateRows, type PrimaryColumnKey } from '../grid';
import { isIndexWithinLength, type PlainObject } from '../utils';

/**
 * Unique id build by the `buildGridId` method to uniquely identify a `GridSchema`
 * inside the `GridSchemaStore`.
 */
export type GridId = string;
/**
 * - Either Name of the root grid provided by the consumer
 * - or a `ColumnKey` whose `ColumnDataType` is resolved to either `object` or `array-object`
 */
export type GridName = string;
/**
 * JSON data provided by the consumer
 */
export type GridData = Readonly<PlainObject | Array<PlainObject>>;
/**
 * - null if `GridSchema` is of the root grid
 * - or an object containing parent grid name and rowId if its sub grid
 */
/**
 * Arrow of plain objects generated by the `generateRows` method
 */
export type GridPlainRows = Array<PlainObject>;
export type GridParentRowId = string | number;
export type GridParent = Readonly<{
	gridName: GridName;
	rowId: GridParentRowId;
}> | null;
/**
 * flag that indicates which GridSchema from the GridSchemaStore is active(rendered) on the UI
 */
export type ActiveGridFlag = boolean;
/**
 * object containing details of a grid opened by the user, it is stored in `GridSchemaStore`
 */
export type GridSchema = {
	gridId: GridId;
	gridName: GridName;
	gridData: GridData;
	gridPlainRows: GridPlainRows;
	gridPrimaryColumnKey: PrimaryColumnKey;
	gridParent: GridParent; // TODO: Remove this and derive parent from gridId
	isActiveGrid: ActiveGridFlag;
};
/**
 * Array of `GridSchema`s containing details of multiple grids that were opened by the user
 * previously and currently.
 */
export type GridSchemaStore = Array<GridSchema>;
export type GridSchemaStoreIndex = number;

/**
 * Creates a new `GridSchemaStore` based on the provided grid name and data
 * @param gridName Name of the root grid
 * @param gridData JSON data of the root grid
 * @returns newly initialised `GridSchemaStore`
 */
export function init(gridName: GridName, gridData: GridData): GridSchemaStore {
	const gridParent = null;
	const gridId = buildGridId(gridName, gridParent);
	const { gridPlainRows, gridPrimaryColumnKey } = generateRows(gridData);
	return [
		{
			gridId,
			gridName,
			gridData,
			gridPlainRows,
			gridPrimaryColumnKey,
			gridParent,
			isActiveGrid: true,
		},
	];
}

/**
 * Builds a unique id to uniquely identify a `GridSchema` inside the `GridSchemaStore`.
 * @param gridName name of the root or sub grid
 * @param gridParent
 * @returns `GridId`
 */
export function buildGridId(
	gridName: GridName,
	gridParent: GridParent
): GridId {
	if (gridParent === null) {
		// no need to randomise this, as there can be only one root grid
		// and even if any nested key in JSON is also same as root gridName
		// then also it won't conflict with root grid as gridName of subgrids
		// will be set as combination of their parent grid names and rowIds
		return gridName;
	} else {
		// using combination of gridParent name and rowId to prevent name conflicts
		return [gridParent.gridName, gridParent.rowId, gridName].join('.');
	}
}

export function buildSchemaForSubGrid(
	parentGridSchema: GridSchema,
	parentGridRowId: GridParentRowId,
	subGridName: GridName,
	subGridData: GridData
) {
	const subGridParent = {
		gridName: parentGridSchema.gridName,
		rowId: parentGridRowId,
	};

	const subGridId = buildGridId(subGridName, subGridParent);
	const { gridPlainRows, gridPrimaryColumnKey } = generateRows(subGridData);

	const subGridSchema: GridSchema = {
		gridId: subGridId,
		gridName: subGridName,
		gridData: subGridData,
		gridPlainRows,
		gridPrimaryColumnKey,
		gridParent: subGridParent,
		isActiveGrid: true,
	};

	return subGridSchema;
}

/**
 * Creates a new `GridSchemaStore` by making the `GridSchema` active on the provided
 * `index` of the given `gridSchemaStore`
 * @param gridSchemaStore
 * @param index
 * @returns `GridSchemaStore`
 */
export function activateGridSchema(
	gridSchemaStore: GridSchemaStore,
	index: GridSchemaStoreIndex
): GridSchemaStore {
	const copy = [...gridSchemaStore];
	setActiveGridSchema(copy, index);

	return copy;
}

/**
 * Creates a new `GridSchemaStore` by activating the gridSchema if it already exists
 * in the provided `gridSchemaStore` otherwise by adding and activating the provided gridSchema
 * @param gridSchemaStore
 * @param gridSchema which needs to added or updated
 * @returns `GridSchemaStore`
 */
export function upsertGridSchema(
	gridSchemaStore: GridSchemaStore,
	gridSchema: GridSchema
): GridSchemaStore {
	const { isPresentInStore, presentIndex } = searchGridSchema(
		gridSchemaStore,
		gridSchema
	);

	if (isPresentInStore) {
		return activateGridSchema(gridSchemaStore, presentIndex);
	} else {
		const activeIndex = getIndexOfActiveGridSchema(gridSchemaStore);
		const slicedUntilActiveIndex = gridSchemaStore.slice(
			0,
			activeIndex + 1
		); // + 1 is added as end param is exclusive but activeIndex should be included in new store
		const copy = [...slicedUntilActiveIndex, gridSchema]; // add the new item in the last index

		return activateGridSchema(copy, copy.length - 1); // activate the added item
	}
}

/**
 * Creates a new `GridSchemaStore` by removing the gridSchema at the provided `removeIndex`
 * All the sub grids of the grid at removeIndex also get removed, so in case the active grid
 * is one of the sub grids, then new active grid will be set which will be the parent of the
 * grid at removeIndex
 * @param gridSchemaStore
 * @param removeIndex index of the `GridSchema` which needs to removed
 * @returns `GridSchemaStore`
 */
export function removeGridSchema(
	gridSchemaStore: GridSchemaStore,
	removeIndex: GridSchemaStoreIndex
): GridSchemaStore {
	if (removeIndex < 1) {
		throw new JsocGridError('Remove Index must be greater than 0');
	}

	const activeIndex = getIndexOfActiveGridSchema(gridSchemaStore);

	if (removeIndex <= activeIndex) {
		setActiveGridSchema(gridSchemaStore, removeIndex - 1);
	}

	return [...gridSchemaStore.slice(0, removeIndex)];
}

/**
 * Returns whether the provided `gridSchema` is present in the `gridSchemaStore`
 * and at what index
 * @param gridSchemaStore
 * @param gridSchema which needs to be searched
 */
export function searchGridSchema(
	gridSchemaStore: GridSchemaStore,
	gridSchema: GridSchema
): { isPresentInStore: boolean; presentIndex: GridSchemaStoreIndex } {
	const presentIndex = getIndexOfGridSchema(gridSchemaStore, gridSchema);

	return {
		isPresentInStore: presentIndex > -1,
		presentIndex,
	};
}

/**
 * Returns index of the provided `gridSchema` in the `gridSchemaStore`
 * @param gridSchemaStore
 * @param gridSchema whose index is needed
 */
export function getIndexOfGridSchema(
	gridSchemaStore: GridSchemaStore,
	gridSchema: GridSchema
): GridSchemaStoreIndex {
	if (gridSchema.gridParent === null) {
		return 0;
	} else {
		return gridSchemaStore.findIndex(
			(item) =>
				item.gridName === gridSchema.gridName &&
				item.gridParent?.gridName === gridSchema.gridParent?.gridName &&
				item.gridParent?.rowId === gridSchema.gridParent?.rowId
		);
	}
}

/**
 * Returns index of the active `gridSchema` in the `gridSchemaStore`
 * @param gridSchemaStore
 */
export function getIndexOfActiveGridSchema(
	gridSchemaStore: GridSchemaStore
): GridSchemaStoreIndex {
	const currentIndex = gridSchemaStore.findIndex((item) => item.isActiveGrid);

	if (currentIndex != -1) {
		return currentIndex;
	} else {
		throw new JsocGridError(
			'Unable to find active item in the GridSchemaStore.'
		);
	}
}

/**
 * Returns the `gridSchema` which is currently active in the `gridSchemaStore`
 * @param gridSchemaStore
 * @returns `GridSchema`
 */
export function getActiveGridSchema(
	gridSchemaStore: GridSchemaStore
): GridSchema {
	return gridSchemaStore[getIndexOfActiveGridSchema(gridSchemaStore)];
}

/**
 * Sets the `gridSchema` as active at the provided `newActiveIndex` of the `gridSchemaStore`
 * @param gridSchemaStore
 */
export function setActiveGridSchema(
	gridSchemaStore: GridSchemaStore,
	newActiveIndex: GridSchemaStoreIndex
): undefined {
	if (isIndexWithinLength(gridSchemaStore, newActiveIndex)) {
		const oldActiveIndex = getIndexOfActiveGridSchema(gridSchemaStore);
		gridSchemaStore[oldActiveIndex].isActiveGrid = false;
		gridSchemaStore[newActiveIndex].isActiveGrid = true;
	} else {
		throw new JsocGridError(
			'New active index is not within the GridSchemaStore length.'
		);
	}
}
