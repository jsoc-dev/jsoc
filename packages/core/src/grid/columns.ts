import {
	isArrayOfObjects,
	isArrayOfStrings,
	isBoolean,
	isConvertibleToDate,
	isFunction,
	isNumber,
	isPlainObject,
	isString,
} from '../utils';
import type { GridRows } from './rows';
import { GridSchema, type GridId } from './store';

/**
 * Property in a `GridRow`
 */
export type ColumnKey = string;
/**
 * Property that has a unique value for all the `GridRows`
 */
export type IdColumnKey = 'id' | typeof FALLBACK_ID_COLUMN_KEY;
/**
 * Value of a property in a `GridRow`.
 * - Note: As `GridRows` are generated from the `GridData` which is a JSON, the value
 * 	can be one of the JSON value types (array, boolean, null, number, object, string)
 */
export type ColumnValue = unknown;
/**
 * Mapping of `ColumnKey` with an array of the all corresponding `ColumnValues`
 * generated by `createColumnKeyValueMap` method
 */
export type ColumnKeyValueMap = Record<ColumnKey, ColumnValue[]>;

/**
 * Data type resolved for a particular `ColumnKey` based on the `GridRows`.
 */
export type ColumnDataType =
	| 'arrayOfObjects'
	| 'arrayOfStrings'
	| 'boolean'
	| 'number'
	| 'object'
	| 'stringDate'
	| 'string'
	| 'unresolved';

export type ColumnDataTypeResolverMethod = (
	columnValues: ColumnValue[]
) => ColumnDataType | false;
/**
 * Ordered list of column data-type resolvers.
 */
export const COLUMN_DATA_TYPE_RESOLVER_LIST: ColumnDataTypeResolverMethod[] = [
	(colValues) => colValues.every(isArrayOfObjects) && 'arrayOfObjects',
	(colValues) => colValues.every(isArrayOfStrings) && 'arrayOfStrings',
	(colValues) => colValues.every(isBoolean) && 'boolean',
	(colValues) => colValues.every(isNumber) && 'number',
	(colValues) => colValues.every(isPlainObject) && 'object',
	(colValues) => colValues.every(isConvertibleToDate) && 'stringDate',
	(colValues) => colValues.every(isString) && 'string',
];

/**
 * ColumnDefinitionProvider method params object.
 *
 * WARNING: Don't provide any value that is not stable in params object.
 * As it can cause stale values issues if the adapter component only calls
 * the generateColumns method once or only when needed.
 * - For example: In React adapters, the generateColumns method is memoised,
 * 	so if we provide any value here that is not under dependency of useMemo
 * 	then ColumnDefinitionProvider will reuse the stale value that can cause issues.
 */
export type ColumnDefinitionProviderParams = {
	/**
	 * `ColumnKey` of the column for which the column definition needs to be generated
	 */
	columnKey: ColumnKey;
	/**
	 * `ColumnDataType` of the column
	 */
	columnDataType: ColumnDataType;
	/**
	 * `GridId` of the grid that will contain the column
	 */
	gridId: GridId;
	/**
	 * `IdColumnKey` of the grid that will contain the column
	 */
	gridIdColumnKey: IdColumnKey;
};

/**
 * Factory method that provides column definition for a column `ColumnKey`.
 */
export type ColumnDefinitionProvider<C> = (
	params: ColumnDefinitionProviderParams
) => C;

/**
 * Mapping of `ColumnKey` and the resolved `ColumnDataType` for the `ColumnKey`
 *  - Generated by `createColumnDataTypeMap` method
 */
export type ColumnDataTypeMap = Record<ColumnKey, ColumnDataType>;

/**
 * Mapper that contains `ColumnDefinitionProvider`s for all the `ColumnDataType`s for the particular
 * Grid UI Component.
 * - Used by the `generateColumns` method to convert the `ColumnDataTypeMap` into an array of column
 * definitions.
 * 
 * NOTE: Main motive of using object instead of a function, is to allow the consumer to reuse methods of
 * default column factory and in case, doesn't want to use any method, then create its own implementation
 * and provide it through custom column factory.
 * 
 * Anatomy of a Column Factory: 
	```
			{
				arrayOfObjects:
				,arrayOfStrings:
				,boolean:
				,number:
				,object:
				,stringDate:
				,string:
				,unresolved:
			}
	```
 */
export type ColumnFactory<C> = Record<
	ColumnDataType,
	ColumnDefinitionProvider<C>
>;
/**
 * If provided, `generateColumns` method will use the methods of customColumnFactory to provide the
 * column defs to the Grid UI Component.
 * - It is an object containing 0 or more custom `ColumnDefinitionProvider`s to override the
 * 	corresponding default `ColumnDefinitionProvider`s for the `ColumnDataType`
 */
export type CustomColumnFactory<C> = Partial<ColumnFactory<C>>;

/**
 * Dynamic key for the fallback id column (column with unique values) that is mandatory to supply
 * in some adapters (example: React MUI DataGrid). It consists of a constant prefix and a
 * random suffix (so that it doesn't clash with any property in gridData JSON)
 *
 * Note that Suffix is generated here and not inside the component as it can improve performance in
 * React components (assuming that when suffix is generated inside the component, the column key
 * changes on every render, and the renderer might rerender whole column thinking it as different
 * column even if the data didn't changed.
 */
export const FALLBACK_ID_COLUMN_KEY =
	'__FallbackIdColumn__' + crypto.randomUUID();

/**
 * Generates column definitions/configurations for the particular Grid UI Component.
 *
 * @param gridSchema schema of the grid for which the columns need to be generated
 * @param defaultColumnFactory default `ColumnFactory` for the Grid UI component
 * @param customColumnFactory custom `ColumnFactory` that is provided by the consumer
 * @returns array of Column definitions
 */
export function generateColumns<C>(
	gridSchema: GridSchema,
	defaultColumnFactory: ColumnFactory<C>,
	customColumnFactory?: CustomColumnFactory<C>
): C[] {
	const { gridId, gridRows, gridIdColumnKey } = gridSchema;
	const columnKeyValueMap = createColumnKeyValueMap(gridRows);
	const columnDataTypeMap = createColumnDataTypeMap(columnKeyValueMap);
	const columnDataTypeEntries = Object.entries(columnDataTypeMap);

	const columnDefinitionList: C[] = [];

	for (const [columnKey, columnDataType] of columnDataTypeEntries) {
		const columnDefProvider =
			isPlainObject(customColumnFactory) &&
			isFunction(customColumnFactory[columnDataType])
				? customColumnFactory[columnDataType]
				: defaultColumnFactory[columnDataType];

		const colDef = columnDefProvider({
			columnKey,
			columnDataType,
			gridId,
			gridIdColumnKey,
		});
		columnDefinitionList.push(colDef);
	}

	return columnDefinitionList;
}

function createColumnKeyValueMap(plainRows: GridRows): ColumnKeyValueMap {
	const columnKeyValueMapper: ColumnKeyValueMap = {};
	for (const row of plainRows) {
		for (const [columnKey, columnValue] of Object.entries(row)) {
			columnKeyValueMapper[columnKey] =
				columnKeyValueMapper[columnKey] ?? [];
			columnKeyValueMapper[columnKey].push(columnValue);
		}
	}

	return columnKeyValueMapper;
}

function createColumnDataTypeMap(
	columnKeyValueMap: ColumnKeyValueMap
): ColumnDataTypeMap {
	const columnSchemaMap: ColumnDataTypeMap = {};

	for (const [columnKey, columnValues] of Object.entries(columnKeyValueMap)) {
		if (isFallbackIdColumn(columnKey)) {
			continue; // skip this column as data of this column is not part of actual GridData
		}

		let resolvedDataType: ColumnDataType = 'unresolved';
		for (const method of COLUMN_DATA_TYPE_RESOLVER_LIST) {
			const returnVal = method(columnValues);
			if (returnVal) {
				resolvedDataType = returnVal;
				break;
			}
		}

		columnSchemaMap[columnKey] = resolvedDataType;
	}

	return columnSchemaMap;
}

export function isFallbackIdColumn(columnKey: ColumnKey) {
	return columnKey === FALLBACK_ID_COLUMN_KEY;
}
