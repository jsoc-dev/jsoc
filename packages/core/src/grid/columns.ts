import {
	isArrayOfObjects,
	isArrayOfStrings,
	isBoolean,
	isConvertibleToDate,
	isFunction,
	isNumber,
	isPlainObject,
	isString,
} from 'utils';
import { GridSchema, GridPlainRows } from '@/grid';

/**
 * Property name of a `PlainObject` in `GridPlainRows`
 */
export type ColumnKey = string;
/**
 * Property name that is present in all the `PlainObject`s in `GridPlainRows` and also has unqiue value in each `PlainObject`
 */
export type PrimaryColumnKey = 'id' | typeof FALLBACK_PRIMARY_COLUMN_KEY;
/**
 * Value of the particular `ColumnKey` in a `PlainObject` of `GridPlainRows`.
 * - Note: As `GridPlainRows` are generated from the `GridData` which is a JSON,
 * 	the value can be one of the JSON value types (array, boolean, null, number, object, string)
 */
export type ColumnValue = unknown;
/**
 * Mapping of `ColumnKey` and an array of the all corresponding `ColumnValue`s in a `PlainObject`
 *  - Generated by `createColumnKeyValueMap` method
 */
export type ColumnKeyValueMap = Record<ColumnKey, ColumnValue[]>;

/**
 * Data type resolved for a particular `ColumnKey` based on the `GridPlainRows`.
 */
export type ColumnDataType =
	| 'arrayOfObjects'
	| 'arrayOfStrings'
	| 'boolean'
	| 'number'
	| 'object'
	| 'stringDate'
	| 'string'
	| 'unresolved';

export interface ColumnDataTypeResolverEntry {
	name: ColumnDataType;
	check: (columnValues: ColumnValue[]) => boolean;
}

/**
 * Ordered list of column data-type resolvers.
 * Each entry contains the data-type name and its matching check function.
 */
export const COLUMN_DATA_TYPE_RESOLVER_LIST: ColumnDataTypeResolverEntry[] = [
	{ name: 'arrayOfObjects', check: (columnValues) => columnValues.every(isArrayOfObjects) },
	{ name: 'arrayOfStrings', check: (columnValues) => columnValues.every(isArrayOfStrings) },
	{ name: 'boolean', check: (columnValues) => columnValues.every(isBoolean) },
	{ name: 'number', check: (columnValues) => columnValues.every(isNumber)  },
	{ name: 'object', check: (columnValues) => columnValues.every(isPlainObject)  },
	{ name: 'stringDate', check: (columnValues) => columnValues.every(isConvertibleToDate)  }, // must come before string
	{ name: 'string', check: (columnValues) => columnValues.every(isString)  },
	{ name: 'unresolved', check: () => true }, // fallback
];

/**
 * ColumnDefinitionProvider method params object
 */
export type ColumnDefinitionProviderParams = {
	/**
	 * ColumnKey for which the column definition needs to be generated
	 */
	columnKey: ColumnKey;
	/**
	 * ColumnDataType of the column
	 */
	columnDataType: ColumnDataType;
	/**
	 * primaryColumnKey resolved by the `generateRows` method
	 */
	primaryColumnKey: ColumnKey;
	/**
	 * schema of the grid that will contain the column
	 */
	gridSchema: GridSchema;
};

/**
 * Factory method that provides column definition for the `columnKey`
 */
export type ColumnDefinitionProvider<C> = (
	params: ColumnDefinitionProviderParams
) => C;

/**
 * Mapping of `ColumnKey` and the resolved `ColumnDataType` for the `ColumnKey`
 *  - Generated by `createColumnDataTypeMap` method
 */
export type ColumnDataTypeMap = Record<ColumnKey, ColumnDataType>;

/**
 * Mapper that contains `ColumnDefinitionProvider`s for all the `ColumnDataType`s for the particular
 * Grid UI Component.
 * - Used by the `generateColumns` method to convert the `ColumnDataTypeMap` into an array of column
 * definitions.
 * 
 * NOTE: Main motive of using object instead of a function, is to allow the consumer to reuse methods of
 * default column factory and in case, doesn't want to use any method, then create its own implementation
 * and provide it through custom column factory.
 * 
 * Anatomy of a Column Factory: 
	```
			{
				arrayOfObjects:
				,arrayOfStrings:
				,boolean:
				,number:
				,object:
				,stringDate:
				,string:
				,unresolved:
			}
	```
 */
export type ColumnFactory<C> = Record<
	ColumnDataType,
	ColumnDefinitionProvider<C>
>;
/**
 * If provided, `generateColumns` method will use the methods of customColumnFactory to provide the
 * column defs to the Grid UI Component.
 * - It is an object containing 0 or more custom `ColumnDefinitionProvider`s to override the
 * 	corresponding default `ColumnDefinitionProvider`s for the `ColumnDataType`
 */
export type CustomColumnFactory<C> = Partial<ColumnFactory<C>>;

/**
 * Dynamic key for the primary column (column with unique values) that is mandatory to supply
 * in some adapters (example: React MUI DataGrid). It consists of a constant prefix and a
 * random suffix (so that it doesn't clash with any property in gridData JSON)
 *
 * Note that Suffix is generated here and not inside the component as it can improve performance in
 * React components (assuming that when suffix is generated inside the component, the column key
 * changes on every render, and the renderer might rerender whole column thinking it as different
 * column even if the data didn't changed.
 */
export const FALLBACK_PRIMARY_COLUMN_KEY =
	'__PrimaryColumn__' + crypto.randomUUID();

/**
 * Generates column definitions/configurations for the particular Grid UI Component.
 *
 * @param plainRows array of objects built by the `generateRows` method
 * @param gridSchema schema of the grid for which the columns need to be generated
 * @param primaryColumnKey property in `plainRows` which has a unique value in each row
 * @param defaultColumnFactory default `ColumnFactory` for the Grid UI component
 * @param customColumnFactory custom `ColumnFactory` that is provided by the consumer
 * @returns array of Column definitions
 */
export function generateColumns<C>(
	plainRows: GridPlainRows,
	gridSchema: GridSchema,
	primaryColumnKey: PrimaryColumnKey,
	defaultColumnFactory: ColumnFactory<C>,
	customColumnFactory?: CustomColumnFactory<C>
): C[] {
	const columnKeyValueMap = createColumnKeyValueMap(plainRows);
	const columnDataTypeMap = createColumnDataTypeMap(columnKeyValueMap);
	const columnDataTypeEntries = Object.entries(columnDataTypeMap);

	const columnDefinitionList: C[] = [];

	for (const [columnKey, columnDataType] of columnDataTypeEntries) {
		const columnDefProvider =
			isPlainObject(customColumnFactory) &&
			isFunction(customColumnFactory[columnDataType])
				? customColumnFactory[columnDataType]
				: defaultColumnFactory[columnDataType];

		const colDef = columnDefProvider({
			columnKey,
			columnDataType,
			primaryColumnKey,
			gridSchema,
		});
		columnDefinitionList.push(colDef);
	}

	return columnDefinitionList;
}

function createColumnKeyValueMap(plainRows: GridPlainRows): ColumnKeyValueMap {
	const columnKeyValueMapper: ColumnKeyValueMap = {};
	for (const row of plainRows) {
		for (const [columnKey, columnValue] of Object.entries(row)) {
			columnKeyValueMapper[columnKey] =
				columnKeyValueMapper[columnKey] ?? [];
			columnKeyValueMapper[columnKey].push(columnValue);
		}
	}

	return columnKeyValueMapper;
}

function createColumnDataTypeMap(
	columnKeyValueMap: ColumnKeyValueMap
): ColumnDataTypeMap {
	const columnSchemaMap: ColumnDataTypeMap = {};

	for (const [columnKey, columnValues] of Object.entries(columnKeyValueMap)) {
		if (isFallbackPrimaryColumn(columnKey)) {
			continue; // skip this column as data of this column is not part of actual GridData
		}

		let resolvedDataType: ColumnDataType = 'unresolved';
		for (const { name, check } of COLUMN_DATA_TYPE_RESOLVER_LIST) {
			if (check(columnValues)) {
				resolvedDataType = name;
				break;
			}
		}

		columnSchemaMap[columnKey] = resolvedDataType;
	}

	return columnSchemaMap;
}

export function isFallbackPrimaryColumn(columnKey: ColumnKey) {
	return columnKey === FALLBACK_PRIMARY_COLUMN_KEY;
}
